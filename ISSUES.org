#+TITLE: Sesame Issues
#+TODO: INPROGRESS | DONE WONTFIX
#+FILETAGS: :sesame:issues:

* DONE [#A] Implement remote remove and update commands          :feature:cli:
CLOSED: [2025-07-22 Tue 15:49]
:PROPERTIES:
:ID:       1
:CREATED:  [2025-07-22 Tue 13:56]
:END:

cli/remote.go:75:
cli/remote.go:77:
db/models/remote.go:131:

The =update= command should have a =--new-name= flag. Or maybe this should be a separate =remote rename= command?


* DONE [#A] Implement close command                              :feature:cli:
CLOSED: [2025-07-23 Wed 13:55]
:PROPERTIES:
:ID:       2
:CREATED:  [2025-07-22 Tue 14:50:02]
:END:

There's currently an =open= command, but not its =close= counterpart to remove access to a service.

It should support both removing access to a single IP address or range, or to the entire service.


* Implement TLS certificate lifecycle management            :feature:security:
:PROPERTIES:
:ID:       3
:CREATED:  [2025-07-22 Tue 13:58]
:END:

TLS certificates are currently hardcoded to expire after 24 hours:
cli/init.go:71:
web/server/api/v1/join.go:113:

We need a simple and intuitive way of handling renewals, revocations, and any other relevant operation.

Here's a list of TLS-related operations that Sonnet 4 came up with which should be done by a system that manages TLS certificates. I filled out the Status and Notes fields.
| Category                   | Operation                          | Description                                                    | Status | Notes |
|----------------------------+------------------------------------+----------------------------------------------------------------+--------+-------|
| Creation & Issuance        | Certificate generation             | Generate public/private key pairs and certificate requests     | ‚úÖ    |       |
|                            | Certificate signing                | Sign certificates using CA or self-signing processes           | ‚úÖ    |       |
|                            | Certificate validation             | Validate certificate format, fields, and policies before issue | ‚úÖ    | This is partly done implicitly. |
|                            | Certificate enrollment             | Manage workflows for certificate requests and approvals        | ‚úÖ    |       |
|----------------------------+------------------------------------+----------------------------------------------------------------+--------+-------|
| Deployment & Distribution  | Certificate installation           | Install certificates on target systems and services            | ‚úÖ    |       |
|                            | Certificate distribution           | Distribute certificates to multiple endpoints automatically    | ‚ùå    | Certs are distributed from the server to a single client at a time. |
|                            | Configuration updates              | Update service configurations to use new certificates          | ‚ùå    |       |
|                            | Automated deployment               | Implement CI/CD pipelines for certificate deployment           | ‚ùå    |       |
|----------------------------+------------------------------------+----------------------------------------------------------------+--------+-------|
| Monitoring & Tracking      | Certificate inventory              | Maintain centralized inventory of all certificates             | ‚ùå    | The server only stores its own certificate. The client certificate it generates is sent to and stored on the client. |
|                            | Expiration monitoring              | Monitor certificate expiration dates and send alerts           | ‚ùì    | Active monitoring and alerting seems out of scope, but there should be warnings, and an easy way to renew valid and expired certs. |
|                            | Usage tracking                     | Track where and how certificates are being used                | ‚ö™    | Audit/activity logging is planned. |
|                            | Compliance reporting               | Generate reports for audit and compliance requirements         | ‚ùì    |       |
|----------------------------+------------------------------------+----------------------------------------------------------------+--------+-------|
| Renewal & Updates          | Automatic renewal                  | Automatically renew certificates before expiration             | ‚ö™    | Seems like the way to go. |
|                            | Certificate replacement            | Replace certificates with minimal service disruption           | ‚ö™    | Same as above. Automatic renewals should be transparent to the client. |
|                            | Rolling updates                    | Update certificates across clusters with zero downtime         | ‚ùå    | Each client will have to request a renewal. |
|                            | Renewal failure handling           | Handle and alert on certificate renewal failures               | ‚ö™    | Sure, in the response for the renewal request. |
|----------------------------+------------------------------------+----------------------------------------------------------------+--------+-------|
| Revocation & Security      | Certificate revocation             | Revoke compromised or invalid certificates                     | ‚ö™    | Must have. Client certificates should be revocable per invite or per user. |
|                            | Revocation list management         | Maintain and publish CRL/OCSP responder services               | ‚ùåÔ∏è   | Seems overkill and out of scope for a self-contained system. |
|                            | Compromise response                | Respond to security incidents involving certificate compromise | ‚ùå    | Seems out of scope. |
|                            | Emergency revocation               | Rapidly revoke certificates in emergency situations            | ‚ö™    | Sure, could be done by revoking the server's CA cert. |
|----------------------------+------------------------------------+----------------------------------------------------------------+--------+-------|
| Operational Management     | Backup and recovery                | Backup certificates, keys, and configuration data              | ‚ùå    | The user can backup the DB and config on their own. |
|                            | Key rotation                       | Rotate cryptographic keys according to security policies       | ‚ùå    | Out of scope. |
|                            | Archive management                 | Archive expired certificates for compliance and forensics      | ‚ùì    |       |
|                            | Integration APIs                   | Provide APIs for external systems and automation tools         | ‚úÖ    |       |
|                            | Audit logging                      | Log all certificate operations for security and compliance     | ‚ö™    |       |
|                            | Role-based access control          | Control access to certificate operations based on user roles   | ‚úÖ    | RBAC is not used, but invite tokens and client certs provide access control. |
|----------------------------+------------------------------------+----------------------------------------------------------------+--------+-------|
| Validation & Health Checks | Certificate chain validation       | Validate complete certificate chains and trust paths           | ‚ùå    | The entire chain is self-contained and managed. |
|                            | Endpoint connectivity testing      | Test SSL/TLS connectivity to certificate-enabled services      | ‚ùå    | Done implicitly by the client. |
|                            | SSL/TLS configuration verification | Verify proper SSL/TLS configuration on target systems          | ‚ùå    | Managed internally. |
|                            | Security policy compliance         | Ensure certificates meet organizational security policies      | ‚ùå    | Maybe in the far future? |

*Legend*:
- ‚úÖ: Done
- üîÑ: In Progress
- ‚ö™: Planned / Not Started
- ‚ö†Ô∏è: Needs Research / Attention
- ‚ùå: Not Applicable
- ‚ùì: Maybe?


* Hide descriptive error messages in /join responses    :enhancement:security:
:PROPERTIES:
:ID:       4
:CREATED:  [2025-07-22 Tue 13:58]
:END:



Currently responses from the =/join= API endpoint include descriptive error messages.
web/server/api/v1/join.go:37:

Such as =invalid invite token=, =failed deriving HMAC key=, etc.

This is helpful for troubleshooting, but it's also information that could be useful for attackers.

All other endpoints behind TLS auth should continue to return descriptive messages, since those clients are trusted.

** Suggested solution

Remove descriptive messages from responses of public endpoints, and respond with status codes only.

Descriptive messages in responses should be configurable by setting an environment variable, such as =SESAME_LOG_LEVEL=DEBUG=.


* Return cancel function from DB.NewContext                      :enhancement:
:PROPERTIES:
:ID:       5
:CREATED:  [2025-07-22 Tue 14:05:25]
:END:

The current =DB.NewContext= method returns a new database context created as a child from a parent context, but not its cancellation function:
db/db.go:61:

This child context is meant to be used in DB operations, and I didn't return the cancellation function out of convenience. Technicaly, there isn't any risk of context leaks, since these contexts will be cancelled when the parent is cancelled, which is guaranteed to happen (I think...).

But this is a code smell anyway, and doing this properly trumps convenience.

So return the cancellation function as well, and cancel the context as usual.



* Update firewall rules on service changes                           :feature:
:PROPERTIES:
:ID:       6
:CREATED:  [2025-07-22 Tue 14:12:30]
:END:

Currently services are just a friendly mapping for a local port, and use a simple CRUD CLI to manage them.
cli/service.go:36:

An important feature to have is for any service changes to also update firewall rules.

For example:

- Removing a service should also remove any associated firewall rules.

- Updating a service port should also update the port in any associated firewall rules.


* [#C] Improve log handling                                      :enhancement:
:PROPERTIES:
:ID:       7
:CREATED:  [2025-07-22 Tue 14:18:52]
:END:

The current structured log handling has a couple of issues.

For example, the =component= field is used in multiple places:
web/client/client.go:35:
web/server/server.go:45:
firewall/manager_option.go:22:

... with the intention that this can be overridden. The problem is that slog doesn't override same field names, but outputs them as duplicate. This might be a desired behavior, but it doesn't make sense with how this field was meant to be used.

Instead, it would be better to use [[https://pkg.go.dev/log/slog#hdr-Groups][Groups]] as a way to group related fields, and avoiding the name clashing. Perhaps =source= might be a better name for the =component= field, in which case it could be more specific and include the file path or even line number where the log event was triggered(?).

Groups could also avoid using underscore as an implicit way of grouping, which is done here:
web/server/api/v1/open.go:25:


* [#C] Resolve minor TODOs                                              :task:
:PROPERTIES:
:ID:       8
:CREATED:  [2025-07-22 Tue 14:31:17]
:END:

There are some lower priority TODOs sprinkled around the codebase:
db/migrator/migrator.go:58:                     // TODO: Log warning
db/migrator/migrator.go:173:    // TODO: Ask user for confirmation before running the plan.
db/models/invite.go:296:                // TODO: Load users in the same query for efficiency
cli/invite.go:123:              // TODO: Add a bulk deletion method?
test/bin/utils.sh:3:# TODO: Disable color when stdout is not a tty

These are not important, but should be resolved eventually.


* Show firewall rules                                                :feature:
:PROPERTIES:
:ID:       9
:CREATED:  [2025-07-22 Tue 14:42:43]
:END:

Currently there's no way for the user to see the firewall rules managed by Sesame. I've been developing and testing with the =nft= CLI, but this shouldn't be expected of users. Sesame is supposed to abstract away the firewall implementation.

** Suggested implementation

Add a top-level =list= or =show= command to display the current rules as they exist in the firewall. This should be a table that shows data using the same terminology and concepts as Sesame, not simply a wrapper around the firewall output.

So at the very least it should show the service name, port, allowed clients, and expiration time.


* Add E2E tests                                                    :task:test:
:PROPERTIES:
:ID:       10
:CREATED:  [2025-07-23 Wed 14:03:31]
:END:

Sesame currently has decent test coverage (62.38%), mostly due to the single =AppRemoteIntegration= test.

However, even that integration test does not represent real-world usage, since it mocks quite a few things, most notably the firewall implementation itself. Meaning there are currently no tests for nftables. I have tested this manually a few weeks ago, so I'm relatively confident it still works, but there have been many changes since then which could've broken things.

The goal of this task is to add end-to-end tests in order to get actual real-world assurance that the application works as expected.


** Background

There is currently a decent set of helpers for running real-world tests:

- The [[file:test/bin/qemu.sh][qemu.sh]] script that simplifies running a VM with QEMU.

- A [[file:justfile::157][justfile recipe]] that downloads a Debian cloud image, creates a base backing image, and boots it with cloud-init, which installs some prerequisite applications.

- Other justfile recipes to copy files and SSH into the VM automatically.

- The VM is setup to allow passwordless login via the SSH pubkey.

All of this makes running manual tests relatively simple, and the system could potentially be reused for running fully automated E2E tests as well.


** Suggested implementation

I think it makes sense to keep the VM testing infrastructure that already exists.

It might be worth checking whether nftables could be tested within containers, in which case [[https://github.com/testcontainers/testcontainers-go][testcontainers]] could simplify some of this, but a) I'm extremely wary of changing nftables rules inside a container, since it could impact Docker itself or my host machine, and b) I'm not a fan of testcontainers, since I've found them to be difficult to run and unreliable in the past. A VM offers better isolation, while I can work on making the bespoke process reliable.

Other options worth looking into are lightweight VMs, micro VMs, etc. Things like Firecracker, and similar. That is a rapidly changing landscape, unlike QEMU, and I'm not confident that the tooling around it would support what I get with QEMU. For example, the ability to setup the VM with cloud-init, passwordless logins, backing disk images, etc.

In any case, once the testing infrastructure is decided, there should be one or more E2E tests that:

- Use the CLI of the compiled Sesame binary.

- Test both happy and error paths.

The focus should primarily be on testing nftables, since that is not possible to test in unit or integration tests.
