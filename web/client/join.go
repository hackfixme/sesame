package client

import (
	"bytes"
	"context"
	"crypto/x509"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"slices"

	"github.com/mr-tron/base58"

	aerrors "go.hackfix.me/sesame/app/errors"
	"go.hackfix.me/sesame/crypto"
	ctypes "go.hackfix.me/sesame/web/client/types"
	"go.hackfix.me/sesame/web/common"
	stypes "go.hackfix.me/sesame/web/server/types"
)

// Auth attempts to connect to a remote Sesame server, and authenticate
// with the given invitation token. The token is a concatenation of a 32-byte
// nonce and the public X25519 key of the remote node, as generated by the
// `invite user` command, and transmitted out-of-band by the user to the client
// node. If the authentication is successful, it returns the TLS server (CA)
// certificate and the TLS client certificate with its private key.
// See the inline comments for details about the process.
func (c *Client) Auth(ctx context.Context, token string) (ctypes.AuthResponseData, error) {
	var cresp ctypes.AuthResponseData

	// 1. Extract the nonce and the remote X25519 public key from the token.
	nonce, remotePubKeyData, err := common.DecodeToken(token)
	if err != nil {
		return cresp, err
	}

	// 2. Generate an ephemeral X25519 key pair, and perform ECDH key exchange
	// in order to generate a shared secret key.
	sharedKey, pubKeyData, err := crypto.ECDHExchange(remotePubKeyData, nil)
	if err != nil {
		return cresp, fmt.Errorf("failed performing ECDH key exchange: %w", err)
	}

	// 3a. Derive a secure HMAC key from the ECDH key.
	hmacKey, err := crypto.DeriveHMACKey(sharedKey, []byte("HMAC key derivation"))
	if err != nil {
		return cresp, fmt.Errorf("failed deriving HMAC key: %w", err)
	}

	// 3b. Generate an HMAC by hashing the nonce using the HMAC key derived from
	// the ECDH key. This allows the server to verify that the request comes from
	// a trusted client, and avoids replay attacks if the token is intercepted in
	// transit.
	hmac := crypto.GenerateHMAC(nonce, hmacKey)
	authToken := slices.Concat(nonce, hmac)

	// 4. Send a join request to the remote node, providing the token and the
	// local X25519 public key. If the token is valid and not expired, the remote
	// node will generate a TLS client certificate and private key, encrypt them
	// with the shared key, and send them in the response, along with the server
	// (CA) certificate.
	respBodyDec, err := c.Join(ctx, base58.Encode(authToken), base58.Encode(pubKeyData))
	if err != nil {
		return cresp, err
	}

	// 5. Decrypt the response payload with the shared key.
	// TODO: Should this key be derived?
	var sharedKeyArr [32]byte
	copy(sharedKeyArr[:], sharedKey)
	respBodyJSON, err := crypto.DecryptSymInMemory(respBodyDec, &sharedKeyArr)
	if err != nil {
		return cresp, fmt.Errorf("failed decrypting response body: %w", err)
	}

	// 6. Unmarshal the response data
	var resp stypes.JoinPostResponseData
	err = json.Unmarshal(respBodyJSON, &resp)
	if err != nil {
		return cresp, fmt.Errorf("failed unmarshalling response body: %w", err)
	}

	// 7. Parse and decode the certificates.
	tlsCACert, err := x509.ParseCertificate(resp.TLSCACert)
	if err != nil {
		return cresp, fmt.Errorf("failed parsing TLS CA certificate: %w", err)
	}

	tlsClientCert, err := crypto.DecodeTLSCert(resp.TLSClientCert)
	if err != nil {
		return cresp, fmt.Errorf("failed decoding TLS client certificate: %w", err)
	}

	cresp.TLSCACert = tlsCACert
	cresp.TLSClientCert = &tlsClientCert

	return cresp, nil
}

// Join sends a request to the remote Sesame node to authenticate the
// local node as a client, and allow priviledged operations on the remote node,
// such as changing firewall rules. The token is generated by the server using
// the `invite user` command, and is sent in the Authorization header. The
// pubKey is the client's X25519 public key, and is sent in the request body. If
// the token is valid and not expired, the server will generate a TLS client
// certificate, and return it in the response body along with the client's
// Ed25519 private key and the server's CA certificate, encrypted with the
// shared ECDH key. This method returns the decoded but encrypted response body.
func (c *Client) Join(ctx context.Context, token, pubKey string) (respBodyDec []byte, rerr error) {
	url := &url.URL{Scheme: "http", Host: c.address, Path: "/api/v1/join"}

	reqCtx, cancelReqCtx := context.WithCancel(ctx)
	defer cancelReqCtx()

	req, err := http.NewRequestWithContext(
		reqCtx, http.MethodPost, url.String(), bytes.NewBufferString(pubKey))
	errFields := []any{"url", url.String(), "method", req.Method}
	if err != nil {
		return nil, aerrors.NewWithCause("failed creating request", err, errFields...)
	}

	req.Header.Set("Authorization", token)

	resp, err := c.Do(req)
	if err != nil {
		return nil, aerrors.NewWithCause("failed sending request", err, errFields...)
	}
	defer func() {
		if err = resp.Body.Close(); err != nil {
			rerr = fmt.Errorf("failed closing response body: %w", err)
		}
	}()

	errFields = append(errFields, "status_code", resp.StatusCode, "status", resp.Status)
	if resp.StatusCode != http.StatusOK {
		return nil, aerrors.NewWith("request failed", errFields...)
	}

	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, aerrors.NewWithCause("failed reading response body", err, errFields...)
	}

	respBodyDec, err = base58.Decode(string(respBody))
	if err != nil {
		return nil, aerrors.NewWithCause("failed decoding response body", err, errFields...)
	}

	return respBodyDec, nil
}
