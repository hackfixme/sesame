package client

import (
	"bytes"
	"context"
	"crypto/x509"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"slices"

	"github.com/mr-tron/base58"

	aerrors "go.hackfix.me/sesame/app/errors"
	"go.hackfix.me/sesame/crypto"
	ctypes "go.hackfix.me/sesame/web/client/types"
	"go.hackfix.me/sesame/web/common"
	stypes "go.hackfix.me/sesame/web/server/types"
)

// Auth attempts to connect to a remote Sesame server, and authenticate
// with the given invitation token. The token is a concatenation of a 32-byte
// nonce and the public X25519 key of the remote node, as generated by the
// `invite user` command, and transmitted out-of-band by the user to the client
// node. If the authentication is successful, it returns the TLS server (CA)
// certificate and the TLS client certificate with its private key.
// See the inline comments for details about the process.
//
//nolint:funlen // A bit long, but splitting it would make it less legible.
func (c *Client) Auth(ctx context.Context, token string) (cresp ctypes.AuthResponseData, rerr error) {
	// 1. Extract the nonce and the remote X25519 public key from the token.
	nonce, remotePubKeyData, err := common.DecodeToken(token)
	if err != nil {
		return cresp, err
	}

	// 2. Generate an ephemeral X25519 key pair, and perform ECDH key exchange
	// in order to generate a shared secret key.
	sharedKey, pubKeyData, err := crypto.ECDHExchange(remotePubKeyData, nil)
	if err != nil {
		return cresp, fmt.Errorf("failed performing ECDH key exchange: %w", err)
	}

	// 3a. Derive a secure HMAC key from the ECDH key.
	hmacKey, err := crypto.DeriveHMACKey(sharedKey, []byte("HMAC key derivation"))
	if err != nil {
		return cresp, fmt.Errorf("failed deriving HMAC key: %w", err)
	}

	// 3b. Generate an HMAC by hashing the nonce using the HMAC key derived from
	// the ECDH key. This allows the server to verify that the request comes from
	// a trusted client, and avoids replay attacks if the token is intercepted in
	// transit.
	hmac := crypto.GenerateHMAC(nonce, hmacKey)
	authToken := slices.Concat(nonce, hmac)

	// 4. Send a join request to the remote node, providing the token and the
	// local X25519 public key. If the token is valid and not expired, the remote
	// node will generate a TLS client certificate and private key, encrypt them
	// with the shared key, and send them in the response, along with the server
	// (CA) certificate.
	respStatusCode, respBody, errFields, err := c.join(ctx, base58.Encode(authToken), base58.Encode(pubKeyData))
	if err != nil {
		return cresp, err
	}

	var reqFailed bool
	if respStatusCode != http.StatusOK {
		// The request failed, but we'll still try to read the response body as it
		// might contain a useful error message.
		reqFailed = true
	}

	// 5. Decode the response body.
	respBodyDec, err := base58.Decode(string(respBody))
	if err != nil {
		if reqFailed {
			return cresp, aerrors.NewWith("request failed", errFields...)
		}
		return cresp, aerrors.NewWithCause("failed decoding response body", err, errFields...)
	}

	// Unmarshal the response and attempt to extract an error message from it.
	unmarshalResponse := func(data []byte) (*stypes.JoinResponse, error) {
		var rd stypes.JoinResponse
		err = json.Unmarshal(data, &rd)
		if err != nil {
			return nil, err //nolint:wrapcheck // Wrapped by caller.
		}
		if rd.Error != nil && rd.Error.Message != "" {
			errFields = append(errFields, "cause", rd.Error.Message)
		}
		return &rd, nil
	}

	// 6. Attempt decrypting the response data with the shared key.
	// If decryption fails and the request *didn't* fail, then it's due to a
	// protocol error, so return right away.
	// However, if decryption fails and the request *did* fail, then attempt to
	// unmarshal the decoded response body and extract any error messages from it
	// anyway. This is done because the request can fail before or after
	// authentication. If the request failed before or during authentication (e.g.
	// because of an invalid token), then the response would be unencrypted. If it
	// failed after authentication succeeded (e.g. during validation or
	// request/response processing), then the response would be encrypted. In
	// either case, if the server is configured with `--error-level=full` or
	// `--error-level=minimal`, then the response could contain an error message
	// that would be helpful to the user for troubleshooting purposes. This double
	// attempt at unmarshalling is meant to extract that error message in both
	// scenarios.
	// TODO: Should this key be derived?
	var sharedKeyArr [32]byte
	copy(sharedKeyArr[:], sharedKey)
	respBodyJSON, err := crypto.DecryptSymInMemory(respBodyDec, &sharedKeyArr)
	if err != nil {
		if !reqFailed {
			return cresp, fmt.Errorf("failed decrypting response body: %w", err)
		}
		_, _ = unmarshalResponse(respBodyDec)
		return cresp, aerrors.NewWith("request failed", errFields...)
	}

	// 7. Try unmarshalling the decrypted response data this time.
	resp, err := unmarshalResponse(respBodyJSON)
	if err != nil {
		if reqFailed {
			return cresp, aerrors.NewWith("request failed", errFields...)
		}
		return cresp, aerrors.NewWithCause("failed unmarshalling response body", err, errFields...)
	}

	// Final request failure check.
	if reqFailed {
		return cresp, aerrors.NewWith("request failed", errFields...)
	}

	// 8. Parse and decode the certificates.
	tlsCACert, err := x509.ParseCertificate(resp.Data.TLSCACert)
	if err != nil {
		return cresp, fmt.Errorf("failed parsing TLS CA certificate: %w", err)
	}

	tlsClientCert, err := crypto.DecodeTLSCert(resp.Data.TLSClientCert)
	if err != nil {
		return cresp, fmt.Errorf("failed decoding TLS client certificate: %w", err)
	}

	cresp.TLSCACert = tlsCACert
	cresp.TLSClientCert = &tlsClientCert

	return cresp, nil
}

// join sends a request to the remote Sesame node to authenticate the
// local node as a client, and allow priviledged operations on the remote node,
// such as changing firewall rules. The token is generated by the server using
// the `invite user` command, and the pubKey is the client's X25519 public key.
// Both are encoded in base58 and sent in the Authorization header. If the token
// is valid and not expired, the server will generate a TLS client certificate,
// and return it in the response body along with the client's Ed25519 private
// key and the server's CA certificate, encrypted with the shared ECDH key. This
// method returns the decoded but encrypted response body.
func (c *Client) join(ctx context.Context, token, pubKey string) (
	statusCode int, respBody []byte, errFields []any, rerr error,
) {
	url := &url.URL{Scheme: "http", Host: c.address, Path: "/api/v1/join"}

	reqData := stypes.JoinRequest{}

	errFields = []any{"url", url.String(), "method", http.MethodPost}

	reqDataJSON, err := json.Marshal(reqData)
	if err != nil {
		return statusCode, respBody, errFields,
			aerrors.NewWithCause("failed marshalling request data", err, errFields...)
	}

	reqCtx, cancelReqCtx := context.WithCancel(ctx)
	defer cancelReqCtx()

	req, err := http.NewRequestWithContext(
		reqCtx, http.MethodPost, url.String(), bytes.NewBuffer(reqDataJSON))
	if err != nil {
		return statusCode, respBody, errFields, fmt.Errorf("failed creating request: %w", err)
	}
	errFields = append(errFields, "method", req.Method)

	req.Header.Set("Authorization", fmt.Sprintf("Bearer %s;%s", token, pubKey))

	resp, err := c.Do(req)
	if err != nil {
		return statusCode, respBody, errFields, fmt.Errorf("failed sending request: %w", err)
	}
	defer func() {
		if err = resp.Body.Close(); err != nil {
			rerr = fmt.Errorf("failed closing response body: %w", err)
		}
	}()

	errFields = append(errFields, "status_code", resp.StatusCode, "status", resp.Status)

	respBody, err = io.ReadAll(resp.Body)
	if err != nil {
		return resp.StatusCode, respBody, errFields, fmt.Errorf("failed reading response body: %w", err)
	}

	return resp.StatusCode, respBody, errFields, nil
}
