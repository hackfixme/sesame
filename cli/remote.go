package cli

import (
	"context"
	"time"

	"github.com/alecthomas/kong"

	actx "go.hackfix.me/sesame/app/context"
	aerrors "go.hackfix.me/sesame/app/errors"
	"go.hackfix.me/sesame/db/models"
	"go.hackfix.me/sesame/web/client"
)

// The Remote command manages remote Sesame nodes.
type Remote struct {
	Add struct {
		Name string `arg:"" help:"The unique name of the remote node."`
		//nolint:lll // Long struct tags are unavoidable.
		Address string `arg:"" help:"The remote address in 'host[:port]' format, where 'host' can be a DNS hostname or an IP address."`
		Token   string `arg:"" help:"The invitation token used for authentication, generated by the remote node."`
	} `cmd:"" help:"Add a new remote node."`
	List   struct{} `cmd:"" aliases:"ls" help:"List remote nodes."`
	Remove struct {
		Name string `arg:"" help:"The unique name of the remote."`
	} `cmd:"" aliases:"rm" help:"Delete a remote node."`
	Update struct {
		Name    string `arg:"" help:"The unique name of the remote."`
		NewName string `help:"A new name to set for this remote."`
		//nolint:lll // Long struct tags are unavoidable.
		Address string `help:"The remote address in 'host[:port]' format, where 'host' can be a DNS hostname or an IP address."`
	} `cmd:"" help:"Update a remote node."`
}

// Run the remote command.
func (r *Remote) Run(kctx *kong.Context, appCtx *actx.Context) error {
	dbCtx := appCtx.DB.NewContext()

	switch kctx.Command() {
	case "remote add <name> <address> <token>":
		c := client.New(r.Add.Address, nil, appCtx.Logger)

		clientCtx, cancelClientCtx := context.WithTimeout(appCtx.Ctx, 10*time.Second)
		defer cancelClientCtx()

		response, err := c.Auth(clientCtx, r.Add.Token)
		if err != nil {
			return err
		}

		remote := models.NewRemote(
			r.Add.Name, r.Add.Address, response.TLSCACert, response.TLSClientCert,
		)
		if err = remote.Save(dbCtx, appCtx.DB, false); err != nil {
			return aerrors.NewWithCause("failed saving remote to the database", err)
		}
	case "remote list":
		remotes, err := models.Remotes(dbCtx, appCtx.DB, nil)
		if err != nil {
			return aerrors.NewWithCause("failed listing remotes", err)
		}

		data := make([][]string, len(remotes))
		for i, r := range remotes {
			data[i] = []string{r.Name, r.Address}
		}

		if len(data) > 0 {
			header := []string{"Name", "Address"}
			err = renderTable(header, data, appCtx.Stdout)
			if err != nil {
				return aerrors.NewWithCause("failed rendering table", err)
			}
		}
	case "remote remove <name>":
		remote := &models.Remote{Name: r.Remove.Name}
		if err := remote.Delete(dbCtx, appCtx.DB); err != nil {
			return aerrors.NewWithCause("failed removing remote", err)
		}
	case "remote update <name>":
		remote := &models.Remote{Name: r.Update.Name}
		if err := remote.Load(dbCtx, appCtx.DB); err != nil {
			return aerrors.NewWithCause("failed loading remote", err, "name", r.Update.Name)
		}
		if r.Update.NewName != "" {
			remote.Name = r.Update.NewName
		}
		if r.Update.Address != "" {
			remote.Address = r.Update.Address
		}
		if err := remote.Save(dbCtx, appCtx.DB, true); err != nil {
			return aerrors.NewWithCause("failed saving remote to the database", err)
		}
	}

	return nil
}
